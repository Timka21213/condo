(*---------------------------------------------------------------------------
   Copyright (c) 2016 Andrew Rudenko. All rights reserved.
   Distributed under the ISC license, see terms at the end of the file.
   %%NAME%% %%VERSION%%
  ---------------------------------------------------------------------------*)
open! Core.Std
open! Async.Std

open Condo

let print_s sexp = printf "%s\n%!" (sexp |> Sexp.to_string_hum)

module C = Cancellable
let%expect_test "Cancellable defer" =
  let v = Ivar.create () in
  let c = C.defer (Ivar.read v) in
  let%bind _ = C.cancel c () in
  print_endline "cancelled";
  [%expect {| cancelled |}] >>= fun () ->
  let v = Ivar.create () in
  let c = C.defer (Ivar.read v) in
  Ivar.fill v "value";
  let%bind res = C.wait c in
  print_s [%message "result" (res : [`Result of string | `Cancelled of unit])];
  [%expect {| (result (res (Result value))) |}]


let%expect_test "Cancellable defer_wait" =
  let v = Ivar.create () in
  let c = C.defer_wait (Ivar.read v) in
  C.cancel c () >>| (fun _ ->  (print_endline "cancelled")) |> don't_wait_for;
  Ivar.fill v "value";
  let%bind res = C.wait c in
  print_s [%message "result" (res : [`Result of string | `Cancelled of unit])];
  [%expect {|
    cancelled
    (result (res (Result value))) |}]

let%expect_test "Cancellable choose" =
  let v1 = Ivar.create () in
  let v2 = Ivar.create () in
  let c1 = C.defer (Ivar.read v1) in
  let c2 = C.defer (Ivar.read v2) in
  let res = C.choose
    [C.choice c1 (fun v -> `Res1 v);
     C.choice c2 (fun v -> `Res2 v)] in
  Ivar.fill v2 "value2";
  let%bind res' = res in
  print_s [%message "result" (res' : [`Res1 of string | `Res2 of string])];
  [%expect {| (result (res' (Res2 value2))) |}]



let () =
  Ppx_inline_test_lib.Runtime.exit ()
